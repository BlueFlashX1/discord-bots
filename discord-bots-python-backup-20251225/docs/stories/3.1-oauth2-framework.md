# Story 3.1: OAuth2 Authentication Framework

**Phase:** 3 - Premium Features  
**Priority:** High  
**Effort:** Large  
**Status:** Blocked (requires Story 1.1)

---

## Story

As a premium user, I want to authenticate via Discord OAuth2 so that I can access premium bot features securely without managing separate credentials.

---

## Context

Premium features require user authentication to verify subscription status and grant access. Discord OAuth2 provides seamless authentication within the Discord ecosystem, eliminating the need for separate login systems.

---

## Acceptance Criteria

### OAuth2 Flow Implementation

- [ ] Web server to handle OAuth2 callbacks
- [ ] Authorization URL generation
- [ ] Token exchange endpoint
- [ ] Token refresh mechanism
- [ ] Secure token storage (encrypted)
- [ ] Token expiration handling

### Permission Scopes

- [ ] Request minimal scopes: `identify`, `email`
- [ ] Scope upgrade flow for additional permissions
- [ ] User consent screen explains permissions
- [ ] Ability to revoke permissions

### Token Management

- [ ] Store access and refresh tokens in database
- [ ] Encrypt tokens at rest (AES-256)
- [ ] Automatic token refresh before expiration
- [ ] Token invalidation on logout
- [ ] Cleanup expired tokens (daily cron)

### Authentication Commands

- [ ] `/authenticate` - Start OAuth2 flow
- [ ] `/logout` - Revoke tokens and logout
- [ ] `/account` - Show authentication status
- [ ] Ephemeral responses for security

### Error Handling

- [ ] Handle authorization failures gracefully
- [ ] Handle token exchange errors
- [ ] Handle expired token scenarios
- [ ] Handle revoked permission scenarios
- [ ] Clear error messages to user

---

## Technical Notes

### OAuth2 Flow Diagram

```
User                 Bot                 Discord API
  |                   |                      |
  |-- /authenticate --|                      |
  |                   |                      |
  |<-- Auth URL ------|                      |
  |                   |                      |
  |-- Click URL ------|                      |
  |                   |                      |
  |------------------ Authorize ----------->|
  |                   |                      |
  |<----------------- Redirect w/ code -----|
  |                   |                      |
  |                   |-- Exchange code --->|
  |                   |                      |
  |                   |<-- Access token -----|
  |                   |                      |
  |<-- Success -------|                      |
  |                   |                      |
```

### Implementation

**Web Server (Flask):**

```python
# auth/server.py
from flask import Flask, request, redirect
from auth.oauth2 import OAuth2Manager

app = Flask(__name__)
oauth = OAuth2Manager(
    client_id=os.getenv("DISCORD_CLIENT_ID"),
    client_secret=os.getenv("DISCORD_CLIENT_SECRET"),
    redirect_uri=os.getenv("OAUTH_REDIRECT_URI")
)

@app.route("/auth/callback")
async def oauth_callback():
    code = request.args.get("code")
    state = request.args.get("state")

    # Verify state (CSRF protection)
    if not verify_state(state):
        return "Invalid state", 400

    # Exchange code for token
    try:
        tokens = await oauth.exchange_code(code)
        user_id = extract_user_id(state)

        # Store tokens
        await store_tokens(user_id, tokens)

        return redirect("/auth/success")
    except Exception as e:
        logger.error(f"OAuth error: {e}")
        return redirect("/auth/error")

@app.route("/auth/success")
def success():
    return """
    <html>
        <body>
            <h1>âœ… Authentication Successful!</h1>
            <p>You can now close this window and return to Discord.</p>
        </body>
    </html>
    """
```

**OAuth2 Manager:**

```python
# auth/oauth2.py
import aiohttp
from cryptography.fernet import Fernet

class OAuth2Manager:
    DISCORD_API = "https://discord.com/api/v10"
    AUTHORIZE_URL = "https://discord.com/api/oauth2/authorize"
    TOKEN_URL = "https://discord.com/api/oauth2/token"

    def __init__(self, client_id: str, client_secret: str, redirect_uri: str):
        self.client_id = client_id
        self.client_secret = client_secret
        self.redirect_uri = redirect_uri
        self.fernet = Fernet(os.getenv("ENCRYPTION_KEY").encode())

    def get_authorization_url(self, user_id: int) -> str:
        """Generate OAuth2 authorization URL"""
        state = generate_state(user_id)  # CSRF protection

        params = {
            "client_id": self.client_id,
            "redirect_uri": self.redirect_uri,
            "response_type": "code",
            "scope": "identify email",
            "state": state
        }

        return f"{self.AUTHORIZE_URL}?{urlencode(params)}"

    async def exchange_code(self, code: str) -> dict:
        """Exchange authorization code for access token"""
        data = {
            "client_id": self.client_id,
            "client_secret": self.client_secret,
            "grant_type": "authorization_code",
            "code": code,
            "redirect_uri": self.redirect_uri
        }

        async with aiohttp.ClientSession() as session:
            async with session.post(self.TOKEN_URL, data=data) as resp:
                if resp.status != 200:
                    raise OAuth2Error(f"Token exchange failed: {resp.status}")
                return await resp.json()

    async def refresh_token(self, refresh_token: str) -> dict:
        """Refresh access token"""
        data = {
            "client_id": self.client_id,
            "client_secret": self.client_secret,
            "grant_type": "refresh_token",
            "refresh_token": refresh_token
        }

        async with aiohttp.ClientSession() as session:
            async with session.post(self.TOKEN_URL, data=data) as resp:
                if resp.status != 200:
                    raise OAuth2Error(f"Token refresh failed: {resp.status}")
                return await resp.json()

    def encrypt_token(self, token: str) -> str:
        """Encrypt token for storage"""
        return self.fernet.encrypt(token.encode()).decode()

    def decrypt_token(self, encrypted: str) -> str:
        """Decrypt token from storage"""
        return self.fernet.decrypt(encrypted.encode()).decode()
```

**Token Storage:**

```python
# auth/tokens.py
from database.base import get_session
from database.models import User

async def store_tokens(user_id: int, tokens: dict):
    """Store OAuth2 tokens in database"""
    async with get_session() as session:
        user = await session.get(User, user_id)

        # Encrypt tokens
        user.access_token = oauth.encrypt_token(tokens["access_token"])
        user.refresh_token = oauth.encrypt_token(tokens["refresh_token"])
        user.token_expires_at = datetime.now() + timedelta(
            seconds=tokens["expires_in"]
        )

        await session.commit()

async def get_valid_token(user_id: int) -> str:
    """Get valid access token, refreshing if needed"""
    async with get_session() as session:
        user = await session.get(User, user_id)

        if not user.access_token:
            raise NotAuthenticated("User not authenticated")

        # Check if token expired
        if datetime.now() >= user.token_expires_at:
            # Refresh token
            refresh_token = oauth.decrypt_token(user.refresh_token)
            new_tokens = await oauth.refresh_token(refresh_token)
            await store_tokens(user_id, new_tokens)
            return new_tokens["access_token"]

        return oauth.decrypt_token(user.access_token)
```

### Discord Command

```python
@bot.tree.command(name="authenticate")
async def authenticate(interaction: discord.Interaction):
    """Start OAuth2 authentication"""
    auth_url = oauth.get_authorization_url(interaction.user.id)

    embed = create_embed(
        title="ðŸ” Authentication Required",
        description=(
            "Click the button below to authenticate with Discord.\n\n"
            "**Why authenticate?**\n"
            "â€¢ Access premium features\n"
            "â€¢ Sync your progress across servers\n"
            "â€¢ Unlock exclusive commands\n\n"
            "**What we access:**\n"
            "â€¢ Your Discord username and ID\n"
            "â€¢ Your email (for premium notifications)\n\n"
            "We will never access your messages or private data."
        ),
        color=0x5865F2  # Discord blurple
    )

    view = AuthView(auth_url)
    await interaction.response.send_message(
        embed=embed,
        view=view,
        ephemeral=True  # Only visible to user
    )

class AuthView(discord.ui.View):
    def __init__(self, auth_url: str):
        super().__init__(timeout=300)  # 5 minute timeout
        self.add_item(discord.ui.Button(
            label="Authenticate",
            url=auth_url,
            style=discord.ButtonStyle.link
        ))
```

---

## Security Considerations

### CSRF Protection

Use state parameter to prevent CSRF attacks:

```python
def generate_state(user_id: int) -> str:
    """Generate cryptographically secure state"""
    random_bytes = os.urandom(16)
    data = f"{user_id}:{random_bytes.hex()}:{time.time()}"
    return base64.urlsafe_b64encode(data.encode()).decode()

def verify_state(state: str) -> tuple[bool, int]:
    """Verify state and extract user_id"""
    try:
        decoded = base64.urlsafe_b64decode(state.encode()).decode()
        user_id, random, timestamp = decoded.split(":")

        # Check if state expired (15 minutes)
        if time.time() - float(timestamp) > 900:
            return False, None

        return True, int(user_id)
    except:
        return False, None
```

### Token Encryption

Tokens must be encrypted at rest:

```python
# Generate encryption key (do once, store in env)
from cryptography.fernet import Fernet
key = Fernet.generate_key()
# Store in ENCRYPTION_KEY environment variable
```

### HTTPS Required

OAuth2 requires HTTPS in production:

- Use Let's Encrypt for free SSL certificates
- Redirect HTTP to HTTPS
- Set secure cookie flags

---

## Infrastructure Requirements

### Web Server

- Flask or FastAPI for OAuth callbacks
- HTTPS certificate (Let's Encrypt)
- Public domain or subdomain
- Port 443 exposed

### Environment Variables

```bash
# OAuth2 Configuration
DISCORD_CLIENT_ID=your_client_id
DISCORD_CLIENT_SECRET=your_client_secret
OAUTH_REDIRECT_URI=https://yourdomain.com/auth/callback

# Encryption
ENCRYPTION_KEY=your_fernet_key_here

# Web Server
WEB_SERVER_HOST=0.0.0.0
WEB_SERVER_PORT=5000
```

### Database Schema Update

```sql
ALTER TABLE users
ADD COLUMN access_token TEXT,
ADD COLUMN refresh_token TEXT,
ADD COLUMN token_expires_at TIMESTAMP;

-- Index for token cleanup cron
CREATE INDEX idx_users_token_expiry
ON users(token_expires_at)
WHERE access_token IS NOT NULL;
```

---

## Dependencies

- Flask or FastAPI (web server)
- aiohttp (async HTTP)
- cryptography (token encryption)
- python-dotenv (environment)

---

## Testing Requirements

- [ ] Unit tests for OAuth2 flow
- [ ] Unit tests for token encryption/decryption
- [ ] Unit tests for token refresh
- [ ] Integration tests for full OAuth flow
- [ ] Security tests (CSRF, token leakage)
- [ ] Load tests for concurrent authentications

---

## Rollout Plan

1. **Phase 1:** Deploy web server (staging)
2. **Phase 2:** Test OAuth flow with test users
3. **Phase 3:** Security audit
4. **Phase 4:** Deploy to production
5. **Phase 5:** Enable `/authenticate` command
6. **Phase 6:** Monitor for issues

---

## Success Metrics

- OAuth completion rate > 90%
- Token refresh success rate > 99%
- Zero token leakage incidents
- Authentication time < 10 seconds
- No CSRF attacks detected

---

## Future Enhancements

- Multi-factor authentication
- Session management (multiple devices)
- OAuth scope management UI
- Third-party integrations (GitHub, Google)

---

## Related Stories

- Story 1.1: Shared Utilities Enhancement
- Story 3.2: Premium Feature Gating
- Story 3.3: Payment Integration

---

**Created:** 2025-12-21  
**Estimated Completion:** 4 weeks
