"""
Grammar Teacher Bot - PREMIUM GRAMMAR CORRECTOR

Features:
- Advanced grammar detection with contextual analysis
- Multiple sentence variations and rephrase options
- Tone analysis and style suggestions
- Monitors ALL messages 24/7
- Sends EPHEMERAL corrections in same channel (only user sees them)
- User can dismiss messages
- English (US) only with advanced rules
- Smart filtering (ignores minor issues)
- Cooldown system (not annoying)
- Opt-out available
- Smart pattern tracking and trend analysis
- Shows corrected sentence + multiple variations
- Readability scoring and complexity analysis
"""

import os
import sys

# Ensure conda environment packages are accessible
CONDA_ENV_PATH = "/opt/homebrew/Caskroom/miniforge/base/lib/python3.12/site-packages"
if CONDA_ENV_PATH not in sys.path:
    sys.path.insert(0, CONDA_ENV_PATH)

from datetime import datetime

import discord

# Import AI grammar checker
from ai_grammar import check_grammar_ai, get_ai_variations
from analysis import analyze_readability, get_tone_analysis
from budget_monitor import get_budget_status

# Import modular components
from config import *
from discord import app_commands
from discord.ext import commands
from dotenv import load_dotenv
from utils import (
    is_auto_check_enabled,
    load_stats,
    set_auto_check,
    track_error_pattern,
    update_user_stats,
)

# Check if AI is available
AI_GRAMMAR_AVAILABLE = os.getenv("OPENAI_API_KEY") is not None
if not AI_GRAMMAR_AVAILABLE:
    print("‚ö†Ô∏è  WARNING: OPENAI_API_KEY not found in .env file")
    print("   Add your OpenAI API key to enable AI grammar checking")
    print("   Get one at: https://platform.openai.com/api-keys")
    print("   Add to .env: OPENAI_API_KEY=sk-...")
else:
    print("‚úÖ AI Grammar Checking enabled (OpenAI GPT-4o-mini)")
    print("   Best available model for grammar correction")


try:
    import textstat

    READABILITY_AVAILABLE = True
except ImportError:
    READABILITY_AVAILABLE = False
    print("WARNING: textstat not installed. Readability analysis disabled.")

try:
    import nltk
    from nltk.tokenize import sent_tokenize, word_tokenize

    NLTK_AVAILABLE = True
    # Download required NLTK data silently
    try:
        nltk.data.find("tokenizers/punkt")
    except LookupError:
        nltk.download("punkt", quiet=True)
except ImportError:
    NLTK_AVAILABLE = False
    print("WARNING: nltk not installed. Advanced analysis disabled.")

# Load environment
load_dotenv()
TOKEN = os.getenv("BOT_TOKEN_GRAMMAR") or os.getenv("BOT_TOKEN_1")

# Bot setup
intents = discord.Intents.default()
intents.message_content = True  # REQUIRED to read messages
intents.members = True  # For user info
bot = commands.Bot(
    command_prefix="!",
    intents=intents,
    description="Grammar Teacher Bot - Auto-detection with private corrections!",
)

# Cooldown tracking (user_id: last_correction_time)
# Note: Uses COOLDOWN_SECONDS from config.py
last_correction_time = {}


def should_ignore_message(message):
    """Determine if message should be ignored"""

    # Ignore bot messages
    if message.author.bot:
        return True

    # Ignore commands
    if message.content.startswith(("/", "!", "?", ".")):
        return True

    # Ignore very short messages (< 10 characters)
    if len(message.content.strip()) < 10:
        return True

    # Ignore messages with only emojis/links
    if message.content.startswith(("http://", "https://", "<:", "<a:")):
        return True

    # Ignore code blocks
    if "```" in message.content:
        return True

    return False


# ============================================================================
# HELPER FUNCTIONS (NOT IN MODULES)
# ============================================================================


def is_on_cooldown(user_id):
    """Check if user is on cooldown"""
    if user_id not in last_correction_time:
        return False

    time_since_last = datetime.now() - last_correction_time[user_id]
    return time_since_last.total_seconds() < COOLDOWN_SECONDS


def set_cooldown(user_id):
    """Set cooldown for user"""
    last_correction_time[user_id] = datetime.now()


def analyze_trends(user_stats):
    """Analyze error patterns and provide smart recommendations"""
    if not user_stats:
        return None

    error_patterns = user_stats.get("error_patterns", {})
    if not error_patterns:
        return None

    # Sort patterns by frequency
    sorted_patterns = sorted(error_patterns.items(), key=lambda x: x[1], reverse=True)

    # Get top 3 common patterns
    top_patterns = sorted_patterns[:3]

    # Analyze trends
    recommendations = []

    for pattern_key, count in top_patterns:
        error_type, error_msg = pattern_key.split(":", 1)

        if error_type == "grammar":
            if count >= 5:
                recommendations.append(
                    f"Grammar issue repeated {count}x: Focus on sentence structure"
                )
            elif count >= 3:
                recommendations.append(
                    f"Grammar pattern ({count}x): Review verb tenses and agreement"
                )

        elif error_type == "misspelling":
            if count >= 5:
                recommendations.append(
                    f"Spelling issue repeated {count}x: Consider using spell-check"
                )
            elif count >= 3:
                recommendations.append(
                    f"Spelling pattern ({count}x): Review commonly misspelled words"
                )

        elif error_type == "typographical":
            if count >= 5:
                recommendations.append(
                    f"Typo repeated {count}x: Slow down when typing or proofread"
                )

    # Calculate improvement trend
    error_history = user_stats.get("error_history", [])
    if len(error_history) >= 10:
        recent_errors = error_history[-5:]
        older_errors = error_history[-10:-5]

        if len(recent_errors) < len(older_errors):
            recommendations.insert(0, "IMPROVING: Fewer errors in recent messages!")
        elif len(recent_errors) > len(older_errors):
            recommendations.insert(
                0, "TREND: Error rate increasing. Take time to proofread."
            )

    return recommendations if recommendations else None


# ============================================================================
# AUTO-DETECTION ENGINE
# ============================================================================


@bot.event
async def on_message(message):
    """Monitor ALL messages for grammar errors using AI"""

    # Process commands first
    await bot.process_commands(message)

    # Skip if should ignore
    if should_ignore_message(message):
        print(f"[DEBUG] Ignoring message from {message.author}: {message.content[:50]}")
        return

    # Skip if AI not available
    if not AI_GRAMMAR_AVAILABLE:
        print("[DEBUG] AI not available")
        return

    # Skip if user has opted out
    if not is_auto_check_enabled(message.author.id):
        print(f"[DEBUG] Auto-check disabled for {message.author}")
        return

    # Skip if user is on cooldown
    if is_on_cooldown(message.author.id):
        print(f"[DEBUG] User {message.author} on cooldown")
        return

    try:
        print(f"[DEBUG] Checking message from {message.author}: {message.content[:50]}")
        # Check the message using AI
        text = message.content
        ai_result = check_grammar_ai(text)

        print(
            f"[DEBUG] AI result: has_errors={ai_result['has_errors']}, error_count={ai_result['error_count']}"
        )

        # Update monitoring stats
        update_user_stats(message.author.id, "messages_monitored")

        # Only notify if there are errors
        if ai_result["has_errors"] and ai_result["error_count"] > 0:
            # Set cooldown to avoid spam
            set_cooldown(message.author.id)

            # Update stats
            update_user_stats(message.author.id, "auto_corrections")
            update_user_stats(
                message.author.id, "errors_found", ai_result["error_count"]
            )

            # Track error patterns
            for error in ai_result["errors"]:
                track_error_pattern(
                    message.author.id, error.get("type", "grammar"), error["message"]
                )

            # Get corrected text and variations
            corrected = ai_result["corrected"]
            variations = get_ai_variations(corrected, text)

            # Get readability analysis
            readability = analyze_readability(corrected)

            # Get tone analysis
            tones = get_tone_analysis(text)

            # Create enhanced correction embed
            embed = discord.Embed(
                title="‚ú® AI Grammar Analysis & Suggestions",
                description=f"**Found {ai_result['error_count']} issue(s)** ‚Ä¢ AI-powered analysis for perfect grammar",
                color=0x5865F2,  # Discord Blurple
            )

            # Show original message (truncated)
            original = text[:200] + "..." if len(text) > 200 else text
            embed.add_field(
                name="üìù Your Original Message", value=f"```{original}```", inline=False
            )

            # Show tone if detected
            if tones and tones != ["Neutral"]:
                tone_text = ", ".join(tones)
                embed.add_field(
                    name="üé≠ Detected Tone", value=f"`{tone_text}`", inline=True
                )

            # Show readability if available
            if readability:
                embed.add_field(
                    name="üìä Readability",
                    value=(
                        f"{readability['emoji']} {readability['level']} "
                        f"(Grade {readability['grade']})"
                    ),
                    inline=True,
                )

            # Show top 3 errors with enhanced formatting (AI errors)
            for i, error in enumerate(ai_result["errors"][:3], 1):
                # Get error details
                error_type = error.get("type", "grammar")
                error_msg = error["message"]
                location = error.get("location", "")
                correction = error.get("correction", "")

                # Create field for this error
                issue_emoji = {
                    "grammar": "üìñ",
                    "spelling": "‚úèÔ∏è",
                    "punctuation": "üî§",
                    "capitalization": "ÔøΩ",
                    "style": "üé®",
                    "word choice": "ÔøΩ",
                    "clarity": "üí°",
                }.get(error_type.lower(), "üìå")

                error_title = f"{issue_emoji} Issue #{i}: {error_type.title()}"
                error_value = f"**Problem:** {error_msg}\n"

                if location:
                    error_value += f"**Location:** `{location}`\n"

                if correction:
                    error_value += f"**Correction:** `{correction}`"

                # Truncate to Discord's 1024 character limit
                if len(error_value) > 1024:
                    error_value = error_value[:1021] + "..."

                embed.add_field(
                    name=error_title,
                    value=error_value,
                    inline=False,
                )

            if ai_result["error_count"] > 3:
                embed.add_field(
                    name="‚ûï More Issues",
                    value=(
                        f"+ {ai_result['error_count'] - 3} "
                        f"additional issues detected"
                    ),
                    inline=False,
                )

            # Add fully corrected version
            if corrected != text:
                corrected_display = (
                    corrected[:300] + "..." if len(corrected) > 300 else corrected
                )
                embed.add_field(
                    name="‚úÖ Corrected Version",
                    value=f"```{corrected_display}```",
                    inline=False,
                )

            # Add AI-generated sentence variations
            if variations:
                variations_text = ""
                for var in variations:
                    var_title = var.get("title", "Variation")
                    var_text = var.get("text", "")
                    var_desc = var.get("description", "")
                    variations_text += (
                        f"\n**{var_title}**\n" f"> {var_text}\n" f"*{var_desc}*\n"
                    )

                if variations_text:
                    embed.add_field(
                        name="ÔøΩ Alternative Phrasings",
                        value=variations_text.strip(),
                        inline=False,
                    )

            embed.set_footer(
                text=(
                    "‚ú® AI-Powered Grammar Analysis ‚Ä¢ "
                    "Only you see this ‚Ä¢ Dismiss anytime"
                )
            )

            # Create view with dismiss button
            class DismissView(discord.ui.View):
                def __init__(self):
                    super().__init__(timeout=600)  # 10 minute timeout

                @discord.ui.button(
                    label="‚úì Dismiss", style=discord.ButtonStyle.secondary, emoji="‚ùå"
                )
                async def dismiss_button(
                    self, interaction: discord.Interaction, button: discord.ui.Button
                ):
                    if interaction.user.id == message.author.id:
                        # Delete the entire message instead of editing it
                        try:
                            await interaction.message.delete()
                        except:
                            # Fallback if can't delete
                            await interaction.response.edit_message(
                                content="*Dismissed*", embed=None, view=None
                            )
                    else:
                        await interaction.response.send_message(
                            "‚ùå This correction is not for you!", ephemeral=True
                        )

                @discord.ui.button(
                    label="Turn Off Auto-Check",
                    style=discord.ButtonStyle.danger,
                    emoji="üîï",
                )
                async def disable_button(
                    self, interaction: discord.Interaction, button: discord.ui.Button
                ):
                    if interaction.user.id == message.author.id:
                        set_auto_check(interaction.user.id, False)
                        # Delete the message and send a new ephemeral confirmation
                        try:
                            await interaction.message.delete()
                            await interaction.response.send_message(
                                "‚úÖ Auto-check disabled! Use `/autocheck on` to re-enable.",
                                ephemeral=True,
                            )
                        except:
                            # Fallback
                            await interaction.response.edit_message(
                                content="‚úÖ Auto-check disabled! Use `/autocheck on` to re-enable.",
                                embed=None,
                                view=None,
                            )
                    else:
                        await interaction.response.send_message(
                            "‚ùå This correction is not for you!", ephemeral=True
                        )

            view = DismissView()

            # Send EPHEMERAL message in the same channel (only user sees it)
            # We need to create a webhook-style ephemeral message
            # The best way is to use followup after creating an interaction
            # But since we don't have an interaction here, we'll send a regular message
            # that can be dismissed and is clearly marked as private

            # Try to send as a reply to their message
            try:
                # Send as a reply with mention disabled to keep it subtle
                correction_msg = await message.reply(
                    content=f"üë§ **Private correction for {message.author.mention}** (only you can see this):",
                    embed=embed,
                    view=view,
                    mention_author=False,
                )

                # Add a reaction to the original message to show it was checked
                try:
                    await message.add_reaction("‚úçÔ∏è")
                except:
                    pass  # Ignore if we can't add reactions

            except discord.Forbidden:
                # Can't reply - try DM as fallback
                try:
                    await message.author.send(
                        content="üí¨ Grammar correction from your message:",
                        embed=embed,
                        view=view,
                    )
                except:
                    pass  # User has DMs disabled, silently fail

    except Exception as e:
        print(f"Error in auto-detection: {e}")


# ============================================================================
# SLASH COMMANDS
# ============================================================================


@bot.tree.command(
    name="autocheck", description="Enable or disable automatic grammar checking"
)
@app_commands.describe(mode="Turn auto-check on or off")
@app_commands.choices(
    mode=[
        app_commands.Choice(name="on", value="on"),
        app_commands.Choice(name="off", value="off"),
    ]
)
async def autocheck(interaction: discord.Interaction, mode: str):
    """Toggle auto-check on/off"""

    if mode == "on":
        set_auto_check(interaction.user.id, True)
        embed = discord.Embed(
            title="‚úÖ Auto-Check Enabled",
            description="I'll now automatically check your messages for grammar errors!",
            color=0x2ECC71,
        )
        embed.add_field(
            name="üìç Where You'll See Corrections",
            value="Corrections appear in the same channel as your message (only you can see them)",
            inline=False,
        )
        embed.add_field(
            name="‚è±Ô∏è Cooldown",
            value="Maximum 1 correction per 5 minutes to avoid spam",
            inline=False,
        )
        embed.add_field(
            name="üéØ What's Checked",
            value="‚Ä¢ Grammar errors\n‚Ä¢ Spelling mistakes\n‚Ä¢ Typos\n‚Ä¢ Shows multiple suggestions + corrected sentence",
            inline=False,
        )
        embed.add_field(
            name="üîï Dismiss Anytime",
            value="Click the dismiss button on any correction to hide it",
            inline=False,
        )
    else:
        set_auto_check(interaction.user.id, False)
        embed = discord.Embed(
            title="Auto-Check Disabled",
            description="I won't automatically check your messages anymore.",
            color=0xE74C3C,
        )
        embed.add_field(
            name="Manual Checks",
            value="You can still use `/check <text>` for manual grammar checks",
            inline=False,
        )

    await interaction.response.send_message(embed=embed, ephemeral=True)


@bot.tree.command(
    name="check", description="Manually check grammar (only you see the result)"
)
@app_commands.describe(text="The text you want to check")
async def slash_check(interaction: discord.Interaction, text: str):
    """Manual grammar check - PRIVATE response with AI analysis"""

    if not AI_GRAMMAR_AVAILABLE:
        await interaction.response.send_message(
            "‚ùå AI grammar checking is not available! "
            "Please add OPENAI_API_KEY to .env file.",
            ephemeral=True,
        )
        return

    await interaction.response.defer(ephemeral=True)

    try:
        # Check grammar using AI
        ai_result = check_grammar_ai(text)
        update_user_stats(interaction.user.id, "manual_checks")

        if ai_result["has_errors"] and ai_result["error_count"] > 0:
            update_user_stats(
                interaction.user.id, "errors_found", ai_result["error_count"]
            )

        if not ai_result["has_errors"] or ai_result["error_count"] == 0:
            # Perfect grammar - show enhanced feedback
            embed = discord.Embed(
                title="‚ú® Excellent Writing!",
                description=(
                    "No grammar issues detected. "
                    "Your text is clear and well-written!"
                ),
                color=0x57F287,  # Discord Green
            )

            # Still show readability
            readability = analyze_readability(text)
            if readability:
                embed.add_field(
                    name="üìä Readability Score",
                    value=(
                        f"{readability['emoji']} {readability['level']}\n"
                        f"Grade Level: {readability['grade']}"
                    ),
                    inline=True,
                )

            # Show tone
            tones = get_tone_analysis(text)
            if tones:
                embed.add_field(name="üé≠ Tone", value=", ".join(tones), inline=True)

            embed.set_footer(text="‚úÖ AI-Powered Check Complete")

        else:
            # Issues found - show AI analysis
            corrected = ai_result["corrected"]
            variations = get_ai_variations(corrected, text)
            readability = analyze_readability(corrected)
            tones = get_tone_analysis(text)

            embed = discord.Embed(
                title="‚ú® AI Grammar Analysis Results",
                description=(
                    f"**Found {ai_result['error_count']} issue(s)** ‚Ä¢ "
                    f"Comprehensive AI analysis below"
                ),
                color=0xFEE75C,  # Discord Yellow
            )

            # Show original text
            original_display = text[:200] + "..." if len(text) > 200 else text
            embed.add_field(
                name="üìù Your Text", value=f"```{original_display}```", inline=False
            )

            # Show tone and readability
            if tones and tones != ["Neutral"]:
                embed.add_field(name="üé≠ Tone", value=", ".join(tones), inline=True)

            if readability:
                embed.add_field(
                    name="üìä Readability",
                    value=f"{readability['emoji']} {readability['level']}",
                    inline=True,
                )

            # Show top issues from AI
            for i, error in enumerate(ai_result["errors"][:3], 1):
                error_type = error.get("type", "grammar")
                error_msg = error["message"]
                correction = error.get("correction", "")

                issue_emoji = {
                    "grammar": "üìñ",
                    "spelling": "‚úèÔ∏è",
                    "punctuation": "üî§",
                    "capitalization": "ÔøΩ",
                    "style": "üé®",
                    "word choice": "ÔøΩ",
                    "clarity": "üí°",
                }.get(error_type.lower(), "üìå")

                error_value = f"**Problem:** {error_msg}"
                if correction:
                    error_value += f"\n**Fix:** `{correction}`"

                embed.add_field(
                    name=f"{issue_emoji} {error_type.title()}",
                    value=error_value,
                    inline=False,
                )

            if ai_result["error_count"] > 3:
                embed.add_field(
                    name="‚ûï More",
                    value=(f"+ {ai_result['error_count'] - 3} " f"additional issues"),
                    inline=False,
                )

            # Corrected version
            if corrected != text:
                corrected_display = (
                    corrected[:300] + "..." if len(corrected) > 300 else corrected
                )
                embed.add_field(
                    name="‚úÖ Corrected",
                    value=f"```{corrected_display}```",
                    inline=False,
                )

            # AI-generated sentence variations
            if variations:
                variations_text = ""
                for var in variations[:2]:  # Show 2 variations
                    var_title = var.get("title", "Variation")
                    var_text = var.get("text", "")
                    variations_text += f"**{var_title}:** {var_text}\n"

                if variations_text:
                    embed.add_field(
                        name="üîÑ Alternatives",
                        value=variations_text.strip(),
                        inline=False,
                    )

            embed.set_footer(text="‚ú® AI-Powered Grammar Analysis")

        await interaction.followup.send(embed=embed, ephemeral=True)

    except Exception as e:
        await interaction.followup.send(
            f"‚ùå Error analyzing text: {str(e)}", ephemeral=True
        )


@bot.tree.command(
    name="stats", description="View your grammar statistics and improvement trends"
)
async def slash_stats(interaction: discord.Interaction):
    """View user stats with smart trend analysis"""

    stats = load_stats()
    user_stats = stats.get(str(interaction.user.id), {})

    if not user_stats:
        embed = discord.Embed(
            title="üìä Grammar Statistics",
            description="You haven't used the bot yet! Start writing messages to see your stats.",
            color=0x95A5A6,
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
        return

    # Create beautiful stats embed
    embed = discord.Embed(
        title=f"üìä Grammar Statistics for {interaction.user.display_name}",
        description="Your writing quality and improvement trends",
        color=0x3498DB,
    )

    # Basic activity stats
    messages_monitored = user_stats.get("messages_monitored", 0)
    auto_corrections = user_stats.get("auto_corrections", 0)
    manual_checks = user_stats.get("manual_checks", 0)
    errors_found = user_stats.get("errors_found", 0)

    # Total activity
    total_checks = messages_monitored + manual_checks
    embed.add_field(
        name="üìù Activity",
        value=f"**{total_checks:,}** total checks\n**{messages_monitored:,}** messages monitored\n**{manual_checks:,}** manual checks",
        inline=True,
    )

    # Error statistics
    embed.add_field(
        name="‚ö†Ô∏è Errors Found",
        value=f"**{errors_found:,}** total issues\n**{auto_corrections:,}** auto-corrections",
        inline=True,
    )

    # Calculate and show accuracy rate
    if messages_monitored > 0:
        accuracy = ((messages_monitored - auto_corrections) / messages_monitored) * 100

        # Visual accuracy bar
        accuracy_emoji = "üü¢" if accuracy >= 90 else "üü°" if accuracy >= 75 else "üî¥"
        accuracy_stars = "‚≠ê" * int(accuracy / 20)  # 5-star rating

        embed.add_field(
            name=f"{accuracy_emoji} Accuracy Rate",
            value=f"**{accuracy:.1f}%** error-free messages\n{accuracy_stars}",
            inline=True,
        )

    # Error breakdown by type
    error_patterns = user_stats.get("error_patterns", {})
    if error_patterns:
        grammar_count = sum(
            count for key, count in error_patterns.items() if "grammar:" in key
        )
        spelling_count = sum(
            count for key, count in error_patterns.items() if "misspelling:" in key
        )
        typo_count = sum(
            count for key, count in error_patterns.items() if "typographical:" in key
        )

        if grammar_count or spelling_count or typo_count:
            # Create visual breakdown
            total_errors = grammar_count + spelling_count + typo_count
            breakdown_text = []

            if grammar_count:
                pct = (grammar_count / total_errors * 100) if total_errors > 0 else 0
                breakdown_text.append(f"üìñ Grammar: **{grammar_count}** ({pct:.0f}%)")
            if spelling_count:
                pct = (spelling_count / total_errors * 100) if total_errors > 0 else 0
                breakdown_text.append(f"‚úèÔ∏è Spelling: **{spelling_count}** ({pct:.0f}%)")
            if typo_count:
                pct = (typo_count / total_errors * 100) if total_errors > 0 else 0
                breakdown_text.append(f"‚å®Ô∏è Typos: **{typo_count}** ({pct:.0f}%)")

            embed.add_field(
                name="üìà Error Breakdown",
                value="\n".join(breakdown_text),
                inline=False,
            )

    # Recent activity trend (last 10 errors)
    error_history = user_stats.get("error_history", [])
    if len(error_history) >= 5:
        recent_5 = error_history[-5:]
        older_5 = (
            error_history[-10:-5] if len(error_history) >= 10 else error_history[:-5]
        )

        recent_count = len(recent_5)
        older_count = len(older_5) if older_5 else 0

        if older_count > 0:
            trend_emoji = (
                "üìâ"
                if recent_count < older_count
                else "üìà" if recent_count > older_count else "‚û°Ô∏è"
            )
            trend_text = (
                f"{trend_emoji} **Improving!** Fewer recent errors"
                if recent_count < older_count
                else (
                    f"{trend_emoji} **Watch out!** More recent errors"
                    if recent_count > older_count
                    else f"{trend_emoji} **Consistent** error rate"
                )
            )

            embed.add_field(
                name="üìä Recent Trend",
                value=trend_text,
                inline=False,
            )

    # Smart recommendations (without showing full history)
    trends = analyze_trends(user_stats)
    if trends:
        # Only show top 3 recommendations
        top_trends = trends[:3]
        embed.add_field(
            name="üí° Smart Recommendations",
            value="\n".join(f"‚Ä¢ {rec}" for rec in top_trends),
            inline=False,
        )

    # Auto-check status
    auto_enabled = is_auto_check_enabled(interaction.user.id)
    status_emoji = "‚úÖ" if auto_enabled else "‚ùå"
    status_text = "Enabled" if auto_enabled else "Disabled"
    embed.add_field(
        name=f"{status_emoji} Auto-Check Status",
        value=f"**{status_text}**"
        + ("\n*Use `/autocheck on` to enable*" if not auto_enabled else ""),
        inline=True,
    )

    # Last active timestamp
    if user_stats.get("last_active"):
        last_active = datetime.fromisoformat(user_stats["last_active"])
        time_ago = datetime.now() - last_active

        if time_ago.days > 0:
            time_text = f"{time_ago.days} day{'s' if time_ago.days > 1 else ''} ago"
        elif time_ago.seconds >= 3600:
            hours = time_ago.seconds // 3600
            time_text = f"{hours} hour{'s' if hours > 1 else ''} ago"
        elif time_ago.seconds >= 60:
            minutes = time_ago.seconds // 60
            time_text = f"{minutes} minute{'s' if minutes > 1 else ''} ago"
        else:
            time_text = "just now"

        embed.set_footer(
            text=f"Last active: {time_text} ‚Ä¢ Tracking since {last_active.strftime('%b %d, %Y')}"
        )

    await interaction.response.send_message(embed=embed, ephemeral=True)


@bot.tree.command(
    name="budget", description="Check AI usage and spending for this month"
)
async def slash_budget(interaction: discord.Interaction):
    """View OpenAI API budget and usage"""

    if not AI_GRAMMAR_AVAILABLE:
        await interaction.response.send_message(
            "‚ùå AI grammar checking is not enabled!", ephemeral=True
        )
        return

    try:
        budget = get_budget_status()

        # Create status embed
        embed = discord.Embed(
            title=f"{budget['emoji']} AI Budget Status - {budget['status']}",
            description=(
                f"**Current Month:** {budget['current_month']}\n"
                f"Using OpenAI GPT-4o-mini for accurate grammar checking"
            ),
            color=(
                0xFF0000
                if budget["suspended"]
                else (
                    0xED4245
                    if budget["percentage"] >= 90
                    else 0xFEE75C if budget["percentage"] >= 75 else 0x57F287
                )
            ),
        )

        # Spending info
        embed.add_field(
            name="üí∞ Spending",
            value=(
                f"**Used:** ${budget['spent']:.4f}\n"
                f"**Limit:** ${budget['limit']:.2f}\n"
                f"**Remaining:** ${budget['remaining']:.4f}"
            ),
            inline=True,
        )

        # Usage info
        percentage_bar = "‚ñà" * int(budget["percentage"] / 10)
        percentage_bar += "‚ñë" * (10 - int(budget["percentage"] / 10))

        embed.add_field(
            name="üìä Usage",
            value=(
                f"**Percentage:** {budget['percentage']:.1f}%\n"
                f"`{percentage_bar}`\n"
                f"**Requests:** {budget['requests']:,}"
            ),
            inline=True,
        )

        # Status message
        if budget["suspended"]:
            embed.add_field(
                name="üö´ Bot Suspended",
                value=(
                    "Budget limit reached! Bot will not process "
                    "grammar checks until next month.\n\n"
                    "**To resume:**\n"
                    "‚Ä¢ Wait for automatic reset (1st of next month)\n"
                    "‚Ä¢ Or increase OPENAI_MAX_BUDGET in .env file"
                ),
                inline=False,
            )
        elif budget["percentage"] >= 90:
            embed.add_field(
                name="‚ö†Ô∏è Warning",
                value=(
                    f"Only ${budget['remaining']:.2f} remaining! "
                    f"Bot will suspend at ${budget['limit']:.2f}"
                ),
                inline=False,
            )
        elif budget["percentage"] >= 75:
            embed.add_field(
                name="üí° Heads Up",
                value=(
                    f"You've used {budget['percentage']:.0f}% of your budget. "
                    f"${budget['remaining']:.2f} remaining."
                ),
                inline=False,
            )
        else:
            embed.add_field(
                name="‚úÖ All Good",
                value=(
                    f"Plenty of budget remaining! "
                    f"At current usage: ~{int(budget['remaining'] / (budget['spent'] / budget['requests']) if budget['requests'] > 0 else 0):,} more checks available."
                ),
                inline=False,
            )

        # Cost estimate
        if budget["requests"] > 0:
            avg_cost = budget["spent"] / budget["requests"]
            embed.add_field(
                name="üìâ Cost Analysis",
                value=(
                    f"**Average per check:** ${avg_cost:.6f}\n"
                    f"**Estimated monthly (1000/day):** "
                    f"${avg_cost * 30000:.2f}\n"
                    f"**Model:** GPT-4o-mini"
                ),
                inline=False,
            )

        embed.set_footer(
            text=(
                "Budget resets monthly ‚Ä¢ "
                "To change limit, update OPENAI_MAX_BUDGET in .env"
            )
        )

        await interaction.response.send_message(embed=embed, ephemeral=True)

    except Exception as e:
        await interaction.response.send_message(
            f"‚ùå Error checking budget: {str(e)}", ephemeral=True
        )


# ============================================================================
# BOT EVENTS
# ============================================================================


@bot.event
async def on_ready():
    """Bot startup"""
    print(f"{bot.user} is online!")
    print(
        f"AI Grammar checking: " f'{"Enabled" if AI_GRAMMAR_AVAILABLE else "Disabled"}'
    )
    print(f"Auto-detection: " f'{"Active" if AI_GRAMMAR_AVAILABLE else "Disabled"}')

    try:
        # Sync commands globally (takes up to 1 hour)
        synced = await bot.tree.sync()
        print(f"Synced {len(synced)} slash commands globally")

        # Also sync to all guilds the bot is in (instant!)
        for guild in bot.guilds:
            try:
                guild_synced = await bot.tree.sync(guild=guild)
                print(f"Synced {len(guild_synced)} commands to guild: {guild.name}")
            except Exception as e:
                print(f"Failed to sync to guild {guild.name}: {e}")

    except Exception as e:
        print(f"Failed to sync commands: {e}")

    await bot.change_presence(
        activity=discord.Game(name="Grammar checking | /autocheck")
    )


@bot.tree.error
async def on_app_command_error(
    interaction: discord.Interaction, error: app_commands.AppCommandError
):
    """Handle errors"""
    print(f"Error: {error}")
    if not interaction.response.is_done():
        await interaction.response.send_message("An error occurred.", ephemeral=True)


# ============================================================================
# RUN BOT
# ============================================================================

if __name__ == "__main__":
    if not TOKEN:
        print("ERROR: No bot token found!")
        print("Add BOT_TOKEN_GRAMMAR to your .env file")
    else:
        print("Starting Grammar Teacher Bot (Auto-Detection Mode)...")
        print("Monitoring all messages 24/7")
        print("Sending private DM corrections")
        print("Users can dismiss messages")
        print("Users can opt-out with /autocheck off")
        bot.run(TOKEN)
